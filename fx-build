#!/bin/bash
# 命令失败检测、未定义变量检测、管道失败检测
set -euo pipefail

# 脚本版本
SCRIPT_VERSION="1.2"

# 获取脚本路径、脚本名
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
SCRIPT_NAME=$(basename "$0")

# 项目根目录：在哪个目录调用脚本，就以哪个目录作为项目根
PROJECT_ROOT="$(pwd)"

# 本地配置文件（用于保存 SDK 环境文件路径，基于当前工作目录/项目根）
LOCAL_CONFIG_FILE="$PROJECT_ROOT/.config"

# 颜色定义（如果终端支持）
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# 显示使用说明
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS] [MODE] [install]

Build Modes:
  sdk     - Cross-compilation with SDK SYSROOT (ARM)
  ubuntu  - Local Ubuntu development build
  server  - Install to system paths (requires root)

Options:
  -h, --help          Show this help message
  -c, --clean         Clean build directory before building
  -v, --verbose       Enable verbose output (show detailed CMake and make commands)
  --version           Show script version
  install             Execute installation after build (optional)

Environment / Config:
  SDK_ENV_FILE        Path to SDK environment setup file (for SDK mode)
                      If set and valid, it will be used and saved to .config
  $LOCAL_CONFIG_FILE  Optional config file. If exists, it will be sourced and
                      should define SDK_ENV_FILE pointing to a valid file.

Examples:
  $SCRIPT_NAME sdk                    # Compile only (SDK mode)
  $SCRIPT_NAME sdk install            # Compile and install (SDK mode)
  $SCRIPT_NAME install sdk            # Install only (for previously built SDK)
  $SCRIPT_NAME ubuntu                 # Compile only (Ubuntu mode)
  $SCRIPT_NAME ubuntu install         # Compile and install (Ubuntu mode)
  $SCRIPT_NAME -c server              # Clean and compile (Server mode)
  $SCRIPT_NAME -v sdk                 # Verbose build output
  SDK_ENV_FILE=/path/to/env $SCRIPT_NAME sdk  # Use custom SDK env file

EOF
}

# 检查必要的工具
check_requirements() {
    local missing_tools=()
    
    if ! command -v cmake &> /dev/null; then
        missing_tools+=("cmake")
    fi
    
    if ! command -v make &> /dev/null; then
        missing_tools+=("make")
    fi
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        log_error "缺少必要的工具: ${missing_tools[*]}"
        log_error "请先安装这些工具"
        exit 1
    fi
    
    # 检查 CMake 版本（可选，但建议）
    if command -v cmake &> /dev/null; then
        local cmake_version
        cmake_version=$(cmake --version | head -n1 | cut -d' ' -f3)
        log_info "CMake 版本: $cmake_version"
    fi
}

# 获取并行任务数（自动检测最大核心数）
get_job_count() {
    if command -v nproc &> /dev/null; then
        nproc
    elif [ -f /proc/cpuinfo ]; then
        grep -c processor /proc/cpuinfo || echo "1"
    else
        echo "1"
    fi
}

# 检查构建目录是否可写
check_build_dir_writable() {
    local build_dir=$1
    local test_dir="$PROJECT_ROOT/$build_dir"
    
    # 如果目录不存在，检查父目录是否可写
    if [ ! -d "$test_dir" ]; then
        test_dir="$PROJECT_ROOT"
    fi
    
    if [ ! -w "$test_dir" ]; then
        log_error "构建目录不可写: $test_dir"
        return 1
    fi
    return 0
}

# 获取 SDK 环境文件路径（始终以交互方式在缺失时询问用户）
get_sdk_env_file() {
    local env_file=""

    # 1) 优先使用环境变量 SDK_ENV_FILE（显式指定）
    if [ -n "${SDK_ENV_FILE:-}" ]; then
        env_file="$SDK_ENV_FILE"
        if [ ! -f "$env_file" ]; then
            log_error "SDK_ENV_FILE 指定的环境文件不存在: $env_file"
            return 1
        fi
        # 保存到本地配置文件，方便下次自动使用
        cat > "$LOCAL_CONFIG_FILE" << EOF
# 自动生成的配置文件，用于记录 SDK 环境文件路径
SDK_ENV_FILE="$env_file"
EOF
        echo "$env_file"
        return 0
    fi

    # 2) 如果存在本地配置文件，则尝试从中加载 SDK_ENV_FILE
    if [ -f "$LOCAL_CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        . "$LOCAL_CONFIG_FILE"
        if [ -n "${SDK_ENV_FILE:-}" ]; then
            env_file="$SDK_ENV_FILE"
            if [ -f "$env_file" ]; then
                echo "$env_file"
                return 0
            else
                log_warn "本地配置文件中的 SDK_ENV_FILE 无效: $env_file"
            fi
        else
            log_warn "本地配置文件中未定义 SDK_ENV_FILE: $LOCAL_CONFIG_FILE"
        fi
    fi

    # 3) 交互模式：提示用户手动输入，成功后写入本地配置文件
    log_warn "未找到 SDK 环境文件配置。"
    while true; do
        echo -n "请输入包含 environment-setup-aarch64-none-linux-gnu 的完整文件路径: " >&2
        read -r env_file
        if [ -z "$env_file" ]; then
            log_error "环境文件路径不能为空"
            continue
        fi
        if [ ! -f "$env_file" ]; then
            log_error "指定的环境文件不存在: $env_file"
            continue
        fi
        break
    done

    # 将用户输入的有效路径写入本地配置文件，方便下次自动使用
    cat > "$LOCAL_CONFIG_FILE" << EOF
# 自动生成的配置文件，用于记录 SDK 环境文件路径
SDK_ENV_FILE="$env_file"
EOF

    echo "$env_file"
    return 0
}

# 验证构建模式
is_valid_mode() {
    local mode=$1
    case "$mode" in
        sdk|ubuntu|server)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# 获取构建目录路径
get_build_dir() {
    local mode=$1
    case "$mode" in
        sdk)
            echo "build_sdk"
            ;;
        ubuntu)
            echo "build_ubuntu"
            ;;
        server)
            echo "build_server"
            ;;
        *)
            echo ""
            ;;
    esac
}

# 清理构建目录
do_clean() {
    local build_mode=$1
    local build_dir=$(get_build_dir "$build_mode")
    
    if [ -z "$build_dir" ]; then
        log_error "无效的构建模式: $build_mode"
        return 1
    fi
    
    if [ -d "$PROJECT_ROOT/$build_dir" ]; then
        log_info "清理构建目录: $build_dir"
        rm -rf "$PROJECT_ROOT/$build_dir"
        log_success "清理完成"
    else
        log_info "构建目录不存在，无需清理: $build_dir"
    fi
}

# 执行安装
do_install() {
    local build_dir=$1
    local build_mode=$2
    
    if [ ! -d "$PROJECT_ROOT/$build_dir" ]; then
        log_error "构建目录不存在: $PROJECT_ROOT/$build_dir"
        log_error "请先执行编译: $SCRIPT_NAME $build_mode"
        exit 1
    fi
    
    cd "$PROJECT_ROOT/$build_dir"
    
    if [ ! -f "Makefile" ]; then
        log_error "CMake 未配置，构建目录不完整: $build_dir"
        log_error "请先执行编译: $SCRIPT_NAME $build_mode"
        exit 1
    fi
    
    log_info "开始安装..."
    if [ "$build_mode" == "server" ]; then
        log_warn "此模式将安装到系统路径"
        log_warn "需要 root 权限"
        if [ "$EUID" -ne 0 ]; then
            log_error "需要 root 权限执行安装"
            log_error "请使用: sudo $SCRIPT_NAME install $build_mode"
            exit 1
        fi
    fi
    
    if ! make install; then
        log_error "安装失败"
        exit 1
    fi
    
    log_success "安装完成！"
}

# 执行编译
do_build() {
    local build_mode=$1
    local clean_flag=${2:-false}
    local verbose=${3:-false}
    
    # 切换到项目根目录（调用脚本时的工作目录）
    cd "$PROJECT_ROOT"
    
    # 记录开始时间
    local start_time
    start_time=$(date +%s)
    
    # 检查构建模式
    if ! is_valid_mode "$build_mode"; then
        log_error "无效的构建模式: '$build_mode'"
        show_usage
        exit 1
    fi
    
    local BUILD_DIR
    local CMAKE_ARGS
    
    case "$build_mode" in
        sdk)
            log_info "=== SDK Build Mode (ARM Cross-compilation) ==="
            
            # 获取环境文件路径（如果缺失会提示用户输入）
            local ENV_FILE
            if ! ENV_FILE=$(get_sdk_env_file); then
                exit 1
            fi

            log_info "加载环境文件: $ENV_FILE"
            if ! source "$ENV_FILE"; then
                log_error "加载环境文件失败: $ENV_FILE"
                exit 1
            fi

            if [ -z "${SDKTARGETSYSROOT:-}" ]; then
                log_error "SDKTARGETSYSROOT 为空，请确认交叉编译环境"
                exit 1
            fi
            log_info "SDKTARGETSYSROOT: $SDKTARGETSYSROOT"
            
            # 验证交叉编译工具链
            if [ -n "${CC:-}" ]; then
                log_info "C 编译器: $CC"
            fi
            if [ -n "${CXX:-}" ]; then
                log_info "C++ 编译器: $CXX"
            fi
            if [ -z "${CC:-}" ] && [ -z "${CXX:-}" ]; then
                log_warn "未检测到 CC 或 CXX 环境变量，请确认交叉编译环境已正确设置"
            fi

            BUILD_DIR="build_sdk"
            CMAKE_ARGS=(-DBUILD_MODE=sdk -DSYSROOT_DIR="${SDKTARGETSYSROOT}" -DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
            ;;

        ubuntu)
            log_info "=== Ubuntu Build Mode ==="
            BUILD_DIR="build_ubuntu"
            CMAKE_ARGS=(-DBUILD_MODE=ubuntu -DCMAKE_BUILD_TYPE=Debug)
            ;;

        server)
            log_info "=== Server Build Mode ==="
            BUILD_DIR="build_server"
            CMAKE_ARGS=(-DBUILD_MODE=server -DCMAKE_BUILD_TYPE=Release)
            ;;

        *)
            log_error "无效的构建模式: '$build_mode'"
            show_usage
            exit 1
            ;;
    esac

    # 清理构建目录（如果需要）
    if [ "$clean_flag" = "true" ]; then
        do_clean "$build_mode"
    fi

    # 检查构建目录是否可写
    if ! check_build_dir_writable "$BUILD_DIR"; then
        exit 1
    fi

    mkdir -p "$BUILD_DIR"
    cd "$BUILD_DIR"

    # 配置 CMake
    local cmake_output
    if [ "$verbose" = "true" ]; then
        if ! cmake .. "${CMAKE_ARGS[@]}"; then
            log_error "CMake 配置失败"
            exit 1
        fi
    else
        if ! cmake_output=$(cmake .. "${CMAKE_ARGS[@]}" 2>&1); then
            log_error "CMake 配置失败"
            echo "$cmake_output" >&2
            exit 1
        fi
    fi

    # 获取并行任务数（自动检测最大核心数）
    local job_count
    job_count=$(get_job_count)
    log_info "开始编译 (使用 $job_count 个并行任务)..."
    
    # 编译
    local make_cmd="make -j$job_count"
    if [ "$verbose" = "true" ]; then
        make_cmd="$make_cmd VERBOSE=1"
    fi
    
    if ! eval "$make_cmd"; then
        log_error "编译失败"
        exit 1
    fi

    # 计算构建时间
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))
    
    log_success "编译完成！(耗时: ${minutes}分${seconds}秒)"
    
    local build_path=$(pwd)
    case "$build_mode" in
        ubuntu)
            log_info "输出目录: $build_path/release"
            ;;
        sdk)
            log_info "构建目录: $build_path"
            ;;
        server)
            log_info "构建目录: $build_path"
            ;;
    esac
}

# 主逻辑
main() {
    # 检查必要工具
    check_requirements
    
    # 解析参数
    local CLEAN_FLAG=false
    local BUILD_MODE=""
    local INSTALL_FLAG=false
    local INSTALL_ONLY=false
    local VERBOSE=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            --version)
                echo "$SCRIPT_NAME version $SCRIPT_VERSION"
                exit 0
                ;;
            -c|--clean)
                CLEAN_FLAG=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            install)
                if [ -z "$BUILD_MODE" ]; then
                    # install 在第一位，表示只安装
                    INSTALL_ONLY=true
                else
                    # install 在构建模式后，表示构建后安装
                    INSTALL_FLAG=true
                fi
                shift
                ;;
            sdk|ubuntu|server)
                if [ -n "$BUILD_MODE" ]; then
                    log_error "只能指定一个构建模式"
                    show_usage
                    exit 1
                fi
                BUILD_MODE="$1"
                shift
                ;;
            *)
                log_error "未知参数: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    # 处理只安装模式
    if [ "$INSTALL_ONLY" = "true" ]; then
        if [ -z "$BUILD_MODE" ]; then
            log_error "安装模式需要指定构建类型"
            log_error "用法: $SCRIPT_NAME install [sdk|ubuntu|server]"
            exit 1
        fi
        
        if ! is_valid_mode "$BUILD_MODE"; then
            log_error "无效的构建模式: '$BUILD_MODE'"
            show_usage
            exit 1
        fi
        
        local build_dir=$(get_build_dir "$BUILD_MODE")
        do_install "$build_dir" "$BUILD_MODE"
        exit 0
    fi
    
    # 检查是否指定了构建模式
    if [ -z "$BUILD_MODE" ]; then
        log_error "请指定构建模式"
        show_usage
        exit 1
    fi
    
    # 执行编译
    do_build "$BUILD_MODE" "$CLEAN_FLAG" "$VERBOSE"
    
    # 如果需要，执行安装
    if [ "$INSTALL_FLAG" = "true" ]; then
        local build_dir=$(get_build_dir "$BUILD_MODE")
        do_install "$build_dir" "$BUILD_MODE"
    fi
}

# 运行主函数
# "$@"：把脚本接收到的所有命令行参数“原封不动地传给 main 函数”
main "$@"
